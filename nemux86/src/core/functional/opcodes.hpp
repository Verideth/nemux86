#pragma once

#include <cstdint>
#include <string>
#include <memory>

// EACH NUMBER AT THE END OF AN INSTRUCTION 
// EXAMPLE SLO_3, 3 BEING THE NUMBER, SHOWS
// WHAT THE OVERRIDE INDEX IS. EACH INSTRUCTION
// CAN HAVE OVERRIDES AND DIFFERENT REGISTERS
// THAT ARE INPUTTED. EACH NUMBER REPRESENTS THAT
// OVERRIDE. 
// 
// (SOME ARE THE SAME INSTRUCTION ALSO,
// FOR EXAMPLE, NOP_9 IS EQUIVALENT TO NOP_10, 
// TAKING THE SAME REGISTERS, AND RETURNING THE
// SAME FUNCTIONAL)
// KEY:
// KEY::
// KEY:::
// +00 +04 +08 +0C AND SO ON = CONTROL INSTRUCTIONS (MOSTLY, ACCORDING TO NESDEV)
// +01 +05 +09 +0D AND SO ON = ALU OPERATIONS
// +02 +06 +0A +0E AND SO ON = READ WRITE AND MODIFY INSTRUCTIONS
// +03 +07 +0B +0F AND SO ON = UNOFFICIAL OPCODES.
enum OPCODE_HEX
{
	
	BRK_1 = 0X00,
	ORA_1 = 0X01,
	STP_1 = 0X02,
	SLO_1 = 0X03,
	NOP_1 = 0X04,
	ORA_2 = 0X05,
	ASL_1 = 0X06,
	SLO_2 = 0X07,
	PHP_1 = 0X08,
	ORA_3 = 0X09,
	ASL_2 = 0X0A,
	ANC_1 = 0X0B,
	NOP_2 = 0X0C,
	ORA_4 = 0X0D,
	ASL_3 = 0X0E,
	SLO_3 = 0X0F,
	BPL_1 = 0X10,
	ORA_5 = 0X11,
	STP_2 = 0X12,
	SLO_4 = 0X13,
	NOP_3 = 0X14,
	ORA_6 = 0X15,
	ASL_4 = 0X16,
	SLO_5 = 0X17,
	CLC_1 = 0X18,
	ORA_7 = 0X19,
	NOP_4 = 0X1A,
	SLO_6 = 0X1B,
	NOP_5 = 0X1C,
	ORA_8 = 0X1D,
	ASL_5 = 0X1E,
	SLO_7 = 0X1F,
	JSR_1 = 0X20,
	AND_1 = 0X21,
	STP_3 = 0X22,
	RLA_1 = 0X23,
	BIT_1 = 0X24,
	AND_2 = 0X25,
	ROL_1 = 0X26,
	RLA_2 = 0X27,
	PLP_1 = 0X28,
	AND_3 = 0X29,
	ROL_2 = 0X2A,
	ANC_2 = 0X2B,
	BIT_2 = 0X2C,
	AND_4 = 0X2D,
	ROL_3 = 0X2E,
	RLA_3 = 0X2F,
	BMI_1 = 0X30,
	AND_5 = 0X31,
	STP_4 = 0X32,
	RLA_4 = 0X33,
	NOP_6 = 0X34,
	AND_6 = 0X35,
	ROL_4 = 0X36,
	RLA_5 = 0X37,
	SEC_1 = 0X38,
	AND_7 = 0X39,
	NOP_7 = 0X3A,
	RLA_6 = 0X3B,
	NOP_8 = 0X3C,
	AND_8 = 0X3D,
	ROL_5 = 0X3E,
	RLA_7 = 0X3F,
	RTI_1 = 0X40,
	EOR_1 = 0X41,
	STP_5 = 0X42,
	SRE_1 = 0X43,
	NOP_9 = 0X44,
	EOR_2 = 0X45,
	LSR_1 = 0X46,
	SRE_2 = 0X47,
	PHA_1 = 0X48,
	EOR_3 = 0X49,
	LSR_2 = 0X4A,
	ALR_1 = 0X4B,
	JMP_1 = 0X4C,
	EOR_4 = 0X4D,
	LSR_3 = 0X4E,
	SRE_3 = 0X4F,
	BVC_1 = 0X50,
	EOR_5 = 0X51,
	STP_6 = 0X52,
	SRE_4 = 0X53,
	NOP_10 = 0X54,
	EOR_6 = 0X55,
	LSR_4 = 0X56,
	SRE_5 = 0X57,
	CLI_1 = 0X58,
	EOR_7 = 0X59,
	NOP_11 = 0X5A,
	SRE_6 = 0X5B,
	NOP_12 = 0X5C,
	EOR_8 = 0X5D,
	LSR_5 = 0X5E,
	SRE_7 = 0X5F,
	RTS_1 = 0X60,
	ADC_1 = 0X61,
	STP_7 = 0X62,
	RRA_1 = 0X63,
	NOP_13 = 0X64,
	ADC_2 = 0X65,
	ROR_1 = 0X66,
	RRA_2 = 0X67,
	PLA_1 = 0X68,
	EOR_9 = 0X69,
	ROR_2 = 0X6A,
	ARR_1 = 0X6B,
	JMP_2 = 0X6C,
	ADC_3 = 0X6D,
	ROR_3 = 0X6E,
	RRA_3 = 0X6F,
	BVS_1 = 0X70,
	ADC_4 = 0X71,
	STP_8 = 0X72,
	RRA_4 = 0X73,
	NOP_14 = 0X74,
	ADC_5 = 0X75,
	ROR_4 = 0X76,
	RRA_5 = 0X77,
	SEI_1 = 0X78,
	ADC_6 = 0X79,
	NOP_15 = 0X7A,
	RRA_6 = 0X7B,
	NOP_16 = 0X7C,
	ADC_7 = 0X7D,
	ROR_5 = 0X7E,
	RRA_7 = 0X7F,
	NOP_17 = 0X80,
	STA_1 = 0X81,
	NOP_18 = 0X82,
	SAX_1 = 0X83,
	STY_1 = 0X84,
	STA_2 = 0X85,
	STX_1 = 0X86,
	SAX_2 = 0X87,
	DEY_1 = 0X88,
	NOP_19 = 0X89,
	TXA_1 = 0X8A,
	XAA_1 = 0X8B,
	STY_2 = 0X8C,
	STA_3 = 0X8D,
	STX_2 = 0X8E,
	SAX_3 = 0X8F,
	BCC_1 = 0X90,
	STA_4 = 0X91,
	STP_9 = 0X92,
	AHX_1 = 0X93,
	STY_3 = 0X94,
	STA_5 = 0X95,
	STX_3 = 0X96,
	SAX_4 = 0X97,
	TYA_1 = 0X98,
	STA_6 = 0X99,
	TXS_1 = 0X9A,
	TAS_1 = 0X9B,
	SHY_1 = 0X9C,
	STA_7 = 0X9D,
	SHX_1 = 0X9E,
	AHX_2 = 0X9F,
	LDY_1 = 0XA0,
	LDA_1 = 0xA1,
	LDX_1 = 0XA2,
	LAX_1 = 0XA3,
	LDY_2 = 0XA4,
	LDA_2 = 0XA5,
	LDX_2 = 0XA6,
	LAX_2 = 0XA7,
	TAY_1 = 0XA8,
	LDA_3 = 0XA9,
	TAX_1 = 0XAA,
	LAX_3 = 0XAB,
	LDY_3 = 0XAC,
	LDA_4 = 0xAD,
	LDX_3 = 0XAE,
	LAX_4 = 0XAF,
	BCS_1 = 0XB0,
	LDA_5 = 0XB1,
	STP_10 = 0XB2,
	LAX_5 = 0XB3,
	LDY_4 = 0XB4,
	LDA_6 = 0XB5,
	LDX_4 = 0XB6,
	LAX_6 = 0XB7,
	CLV_1 = 0XB8,
	LDA_7 = 0XB9,
	TSX_1 = 0XBA,
	LAS_1 = 0XBB,
	LDY_5 = 0XBC,
	LDA_8 = 0XBD,
	LDX_5 = 0XBE,
	LAX_7 = 0XBF,
	CPY_1 = 0XC0,
	CMP_1 = 0XC1,
	NOP_20 = 0XC2,
	DCP_1 = 0XC3,
	CPY_2 = 0XC4,
	CMP_2 = 0XC5,
	DEC_1 = 0XC6,
	DCP_2 = 0XC7,
	INY_1 = 0XC8,
	CMP_3 = 0XC9,
	DEX_1 = 0XCA,
	AXS_1 = 0XCB,
	CPY_3 = 0XCC,
	CMP_4 = 0XCD,
	DEC_2 = 0XCE,
	DCP_3 = 0XCF,
	BNE_1 = 0XD0,
	CMP_5 = 0XD1,
	STP_11 = 0XD2,
	DCP_4 = 0XD3,
	NOP_21 = 0XD4,
	CMP_6 = 0XD5,
	DEC_3 = 0XD6,
	DCP_5 = 0XD7,
	CLD_1 = 0XD8,
	CMP_7 = 0XD9,
	NOP_22 = 0XDA,
	DCP_6 = 0XDB,
	NOP_23 = 0XDC,
	CMP_8 = 0XDD,
	DEC_4 = 0XDE,
	DCP_7 = 0XDF,
	CPX_1 = 0XE0,
	SBC_1 = 0XE1,
	NOP_24 = 0XE2,
	ISC_1 = 0XE3,
	CPX_2 = 0XE4,
	SBC_2 = 0XE5,
	INC_1 = 0XE6,
	ISC_2 = 0XE7,
	INX_1 = 0XE8,
	SBC_3 = 0XE9,
	NOP_25 = 0XEA,
	SBC_4 = 0XEB,
	CPX_3 = 0XEC,
	SBC_5 = 0XED,
	INC_2 = 0XEE,
	ISC_3 = 0XEF,
	BEQ_1 = 0XF0,
	SBC_6 = 0XF1,
	STP_12 = 0XF2,
	ISC_4 = 0XF3,
	NOP_26 = 0XF4,
	SBC_7 = 0XF5,
	INC_3 = 0XF6,
	ISC_5 = 0XF7,
	SED_1 = 0XF8,
	SBC_8 = 0XF9,
	NOP_27 = 0XFA,
	ISC_6 = 0XFB,
	NOP_28 = 0XFC,
	SBC_9 = 0XFD,
	INC_4 = 0XFE,
	ISC_7 = 0XFF
};

// structure for managing opcodes
typedef struct opcode_t
{
	opcode_t() {  }		
	opcode_t(const opcode_t& opcode_object) 
	{
		opcode_name = opcode_object.opcode_name;
		bytecode = opcode_object.bytecode;
		l_endian = opcode_object.l_endian;
		b_endian = opcode_object.b_endian;
	}
	
	std::string opcode_name = ""; // the name of the opcode in std::string format
	std::uint16_t bytecode = 0; // opcodes bytecode
	std::uint16_t l_endian = 0; // little endian
	std::uint16_t b_endian = 0; // big endian
} opcode_t;